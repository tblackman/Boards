{"dependencies":[{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.hyphenate = hyphenate;\nexports.stringHash = stringHash;\nexports.create = create;\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * The unique id is used for unique hashes.\n */\nvar uniqueId = 0;\n/**\n * Tag styles with this string to get unique hashes.\n */\nvar IS_UNIQUE = exports.IS_UNIQUE = '__DO_NOT_DEDUPE_STYLE__';\nvar upperCasePattern = /[A-Z]/g;\nvar msPattern = /^ms-/;\nvar interpolatePattern = /&/g;\nvar escapePattern = /[ !#$%&()*+,./;<=>?@[\\]^`{|}~\"'\\\\]/g;\nvar propLower = function propLower(m) {\n  return \"-\" + m.toLowerCase();\n};\n/**\n * CSS properties that are valid unit-less numbers.\n */\nvar cssNumberProperties = ['animation-iteration-count', 'box-flex', 'box-flex-group', 'column-count', 'counter-increment', 'counter-reset', 'flex', 'flex-grow', 'flex-positive', 'flex-shrink', 'flex-negative', 'font-weight', 'line-clamp', 'line-height', 'opacity', 'order', 'orphans', 'tab-size', 'widows', 'z-index', 'zoom',\n// SVG properties.\n'fill-opacity', 'stroke-dashoffset', 'stroke-opacity', 'stroke-width'];\n/**\n * Map of css number properties.\n */\nvar CSS_NUMBER = Object.create(null);\n// Add vendor prefixes to all unit-less properties.\nfor (var _i = 0, _a = ['-webkit-', '-ms-', '-moz-', '-o-', '']; _i < _a.length; _i++) {\n  var prefix = _a[_i];\n  for (var _b = 0, cssNumberProperties_1 = cssNumberProperties; _b < cssNumberProperties_1.length; _b++) {\n    var property = cssNumberProperties_1[_b];\n    CSS_NUMBER[prefix + property] = true;\n  }\n}\n/**\n * Escape a CSS class name.\n */\nvar escape = exports.escape = function escape(str) {\n  return str.replace(escapePattern, '\\\\$&');\n};\n/**\n * Transform a JavaScript property into a CSS property.\n */\nfunction hyphenate(propertyName) {\n  return propertyName.replace(upperCasePattern, propLower).replace(msPattern, '-ms-'); // Internet Explorer vendor prefix.\n}\n/**\n * Generate a hash value from a string.\n */\nfunction stringHash(str) {\n  var value = 5381;\n  var len = str.length;\n  while (len--) {\n    value = value * 33 ^ str.charCodeAt(len);\n  }return (value >>> 0).toString(36);\n}\n/**\n * Transform a style string to a CSS string.\n */\nfunction styleToString(key, value) {\n  if (typeof value === 'number' && value !== 0 && !CSS_NUMBER[key]) {\n    return key + \":\" + value + \"px\";\n  }\n  return key + \":\" + value;\n}\n/**\n * Sort an array of tuples by first value.\n */\nfunction sortTuples(value) {\n  return value.sort(function (a, b) {\n    return a[0] > b[0] ? 1 : -1;\n  });\n}\n/**\n * Categorize user styles.\n */\nfunction parseStyles(styles, hasNestedStyles) {\n  var properties = [];\n  var nestedStyles = [];\n  var isUnique = false;\n  // Sort keys before adding to styles.\n  for (var _i = 0, _a = Object.keys(styles); _i < _a.length; _i++) {\n    var key = _a[_i];\n    var value = styles[key];\n    if (value !== null && value !== undefined) {\n      if (key === IS_UNIQUE) {\n        isUnique = true;\n      } else if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === 'object' && !Array.isArray(value)) {\n        nestedStyles.push([key.trim(), value]);\n      } else {\n        properties.push([hyphenate(key.trim()), value]);\n      }\n    }\n  }\n  return {\n    styleString: stringifyProperties(sortTuples(properties)),\n    nestedStyles: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),\n    isUnique: isUnique\n  };\n}\n/**\n * Stringify an array of property tuples.\n */\nfunction stringifyProperties(properties) {\n  return properties.map(function (_a) {\n    var name = _a[0],\n        value = _a[1];\n    if (!Array.isArray(value)) return styleToString(name, value);\n    return value.map(function (x) {\n      return styleToString(name, x);\n    }).join(';');\n  }).join(';');\n}\n/**\n * Interpolate CSS selectors.\n */\nfunction interpolate(selector, parent) {\n  if (selector.indexOf('&') > -1) {\n    return selector.replace(interpolatePattern, parent);\n  }\n  return parent + \" \" + selector;\n}\n/**\n * Recursive loop building styles with deferred selectors.\n */\nfunction stylize(cache, selector, styles, list, parent) {\n  var _a = parseStyles(styles, !!selector),\n      styleString = _a.styleString,\n      nestedStyles = _a.nestedStyles,\n      isUnique = _a.isUnique;\n  var pid = styleString;\n  if (selector.charCodeAt(0) === 64 /* @ */) {\n      var rule = cache.add(new Rule(selector, parent ? undefined : styleString, cache.hash));\n      // Nested styles support (e.g. `.foo > @media > .bar`).\n      if (styleString && parent) {\n        var style = rule.add(new Style(styleString, rule.hash, isUnique ? \"u\" + (++uniqueId).toString(36) : undefined));\n        list.push([parent, style]);\n      }\n      for (var _i = 0, nestedStyles_1 = nestedStyles; _i < nestedStyles_1.length; _i++) {\n        var _b = nestedStyles_1[_i],\n            name = _b[0],\n            value = _b[1];\n        pid += name + stylize(rule, name, value, list, parent);\n      }\n    } else {\n    var key = parent ? interpolate(selector, parent) : selector;\n    if (styleString) {\n      var style = cache.add(new Style(styleString, cache.hash, isUnique ? \"u\" + (++uniqueId).toString(36) : undefined));\n      list.push([key, style]);\n    }\n    for (var _c = 0, nestedStyles_2 = nestedStyles; _c < nestedStyles_2.length; _c++) {\n      var _d = nestedStyles_2[_c],\n          name = _d[0],\n          value = _d[1];\n      pid += name + stylize(cache, name, value, list, key);\n    }\n  }\n  return pid;\n}\n/**\n * Register all styles, but collect for selector interpolation using the hash.\n */\nfunction composeStyles(container, selector, styles, isStyle, displayName) {\n  var cache = new Cache(container.hash);\n  var list = [];\n  var pid = stylize(cache, selector, styles, list);\n  var hash = \"f\" + cache.hash(pid);\n  var id = displayName ? displayName + \"_\" + hash : hash;\n  for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {\n    var _a = list_1[_i],\n        selector_1 = _a[0],\n        style = _a[1];\n    var key = isStyle ? interpolate(selector_1, \".\" + escape(id)) : selector_1;\n    style.add(new Selector(key, style.hash, undefined, pid));\n  }\n  return { cache: cache, pid: pid, id: id };\n}\n/**\n * Cache to list to styles.\n */\nfunction join(arr) {\n  var res = '';\n  for (var i = 0; i < arr.length; i++) {\n    res += arr[i];\n  }return res;\n}\n/**\n * Noop changes.\n */\nvar noopChanges = {\n  add: function add() {\n    return undefined;\n  },\n  change: function change() {\n    return undefined;\n  },\n  remove: function remove() {\n    return undefined;\n  }\n};\n/**\n * Implement a cache/event emitter.\n */\nvar Cache = /** @class */function () {\n  function Cache(hash, changes) {\n    if (hash === void 0) {\n      hash = stringHash;\n    }\n    if (changes === void 0) {\n      changes = noopChanges;\n    }\n    this.hash = hash;\n    this.changes = changes;\n    this.sheet = [];\n    this.changeId = 0;\n    this._keys = [];\n    this._children = Object.create(null);\n    this._counters = Object.create(null);\n  }\n  Cache.prototype.add = function (style) {\n    var count = this._counters[style.id] || 0;\n    var item = this._children[style.id] || style.clone();\n    this._counters[style.id] = count + 1;\n    if (count === 0) {\n      this._children[item.id] = item;\n      this._keys.push(item.id);\n      this.sheet.push(item.getStyles());\n      this.changeId++;\n      this.changes.add(item, this._keys.length - 1);\n    } else {\n      // Check if contents are different.\n      if (item.getIdentifier() !== style.getIdentifier()) {\n        throw new TypeError(\"Hash collision: \" + style.getStyles() + \" === \" + item.getStyles());\n      }\n      var oldIndex = this._keys.indexOf(style.id);\n      var newIndex = this._keys.length - 1;\n      var prevChangeId = this.changeId;\n      if (oldIndex !== newIndex) {\n        this._keys.splice(oldIndex, 1);\n        this._keys.push(style.id);\n        this.changeId++;\n      }\n      if (item instanceof Cache && style instanceof Cache) {\n        var prevChangeId_1 = item.changeId;\n        item.merge(style);\n        if (item.changeId !== prevChangeId_1) {\n          this.changeId++;\n        }\n      }\n      if (this.changeId !== prevChangeId) {\n        if (oldIndex === newIndex) {\n          this.sheet.splice(oldIndex, 1, item.getStyles());\n        } else {\n          this.sheet.splice(oldIndex, 1);\n          this.sheet.splice(newIndex, 0, item.getStyles());\n        }\n        this.changes.change(item, oldIndex, newIndex);\n      }\n    }\n    return item;\n  };\n  Cache.prototype.remove = function (style) {\n    var count = this._counters[style.id];\n    if (count > 0) {\n      this._counters[style.id] = count - 1;\n      var item = this._children[style.id];\n      var index = this._keys.indexOf(item.id);\n      if (count === 1) {\n        delete this._counters[style.id];\n        delete this._children[style.id];\n        this._keys.splice(index, 1);\n        this.sheet.splice(index, 1);\n        this.changeId++;\n        this.changes.remove(item, index);\n      } else if (item instanceof Cache && style instanceof Cache) {\n        var prevChangeId = item.changeId;\n        item.unmerge(style);\n        if (item.changeId !== prevChangeId) {\n          this.sheet.splice(index, 1, item.getStyles());\n          this.changeId++;\n          this.changes.change(item, index, index);\n        }\n      }\n    }\n  };\n  Cache.prototype.merge = function (cache) {\n    for (var _i = 0, _a = cache._keys; _i < _a.length; _i++) {\n      var id = _a[_i];\n      this.add(cache._children[id]);\n    }\n    return this;\n  };\n  Cache.prototype.unmerge = function (cache) {\n    for (var _i = 0, _a = cache._keys; _i < _a.length; _i++) {\n      var id = _a[_i];\n      this.remove(cache._children[id]);\n    }\n    return this;\n  };\n  Cache.prototype.clone = function () {\n    return new Cache(this.hash).merge(this);\n  };\n  return Cache;\n}();\nexports.Cache = Cache;\n/**\n * Selector is a dumb class made to represent nested CSS selectors.\n */\n\nvar Selector = /** @class */function () {\n  function Selector(selector, hash, id, pid) {\n    if (id === void 0) {\n      id = \"s\" + hash(selector);\n    }\n    if (pid === void 0) {\n      pid = '';\n    }\n    this.selector = selector;\n    this.hash = hash;\n    this.id = id;\n    this.pid = pid;\n  }\n  Selector.prototype.getStyles = function () {\n    return this.selector;\n  };\n  Selector.prototype.getIdentifier = function () {\n    return this.pid + \".\" + this.selector;\n  };\n  Selector.prototype.clone = function () {\n    return new Selector(this.selector, this.hash, this.id, this.pid);\n  };\n  return Selector;\n}();\nexports.Selector = Selector;\n/**\n * The style container registers a style string with selectors.\n */\n\nvar Style = /** @class */function (_super) {\n  __extends(Style, _super);\n  function Style(style, hash, id) {\n    if (id === void 0) {\n      id = \"c\" + hash(style);\n    }\n    var _this = _super.call(this, hash) || this;\n    _this.style = style;\n    _this.hash = hash;\n    _this.id = id;\n    return _this;\n  }\n  Style.prototype.getStyles = function () {\n    return this.sheet.join(',') + \"{\" + this.style + \"}\";\n  };\n  Style.prototype.getIdentifier = function () {\n    return this.style;\n  };\n  Style.prototype.clone = function () {\n    return new Style(this.style, this.hash, this.id).merge(this);\n  };\n  return Style;\n}(Cache);\nexports.Style = Style;\n/**\n * Implement rule logic for style output.\n */\n\nvar Rule = /** @class */function (_super) {\n  __extends(Rule, _super);\n  function Rule(rule, style, hash, id, pid) {\n    if (style === void 0) {\n      style = '';\n    }\n    if (id === void 0) {\n      id = \"a\" + hash(rule + \".\" + style);\n    }\n    if (pid === void 0) {\n      pid = '';\n    }\n    var _this = _super.call(this, hash) || this;\n    _this.rule = rule;\n    _this.style = style;\n    _this.hash = hash;\n    _this.id = id;\n    _this.pid = pid;\n    return _this;\n  }\n  Rule.prototype.getStyles = function () {\n    return this.rule + \"{\" + this.style + join(this.sheet) + \"}\";\n  };\n  Rule.prototype.getIdentifier = function () {\n    return this.pid + \".\" + this.rule + \".\" + this.style;\n  };\n  Rule.prototype.clone = function () {\n    return new Rule(this.rule, this.style, this.hash, this.id, this.pid).merge(this);\n  };\n  return Rule;\n}(Cache);\nexports.Rule = Rule;\n/**\n * The FreeStyle class implements the API for everything else.\n */\n\nvar FreeStyle = /** @class */function (_super) {\n  __extends(FreeStyle, _super);\n  function FreeStyle(hash, debug, id, changes) {\n    if (hash === void 0) {\n      hash = stringHash;\n    }\n    if (debug === void 0) {\n      debug = typeof process !== 'undefined' && \"development\" !== 'production';\n    }\n    if (id === void 0) {\n      id = \"f\" + (++uniqueId).toString(36);\n    }\n    var _this = _super.call(this, hash, changes) || this;\n    _this.hash = hash;\n    _this.debug = debug;\n    _this.id = id;\n    return _this;\n  }\n  FreeStyle.prototype.registerStyle = function (styles, displayName) {\n    var debugName = this.debug ? displayName : undefined;\n    var _a = composeStyles(this, '&', styles, true, debugName),\n        cache = _a.cache,\n        id = _a.id;\n    this.merge(cache);\n    return id;\n  };\n  FreeStyle.prototype.registerKeyframes = function (keyframes, displayName) {\n    return this.registerHashRule('@keyframes', keyframes, displayName);\n  };\n  FreeStyle.prototype.registerHashRule = function (prefix, styles, displayName) {\n    var debugName = this.debug ? displayName : undefined;\n    var _a = composeStyles(this, '', styles, false, debugName),\n        cache = _a.cache,\n        pid = _a.pid,\n        id = _a.id;\n    var rule = new Rule(prefix + \" \" + escape(id), undefined, this.hash, undefined, pid);\n    this.add(rule.merge(cache));\n    return id;\n  };\n  FreeStyle.prototype.registerRule = function (rule, styles) {\n    this.merge(composeStyles(this, rule, styles, false).cache);\n  };\n  FreeStyle.prototype.registerCss = function (styles) {\n    this.merge(composeStyles(this, '', styles, false).cache);\n  };\n  FreeStyle.prototype.getStyles = function () {\n    return join(this.sheet);\n  };\n  FreeStyle.prototype.getIdentifier = function () {\n    return this.id;\n  };\n  FreeStyle.prototype.clone = function () {\n    return new FreeStyle(this.hash, this.debug, this.id, this.changes).merge(this);\n  };\n  return FreeStyle;\n}(Cache);\nexports.FreeStyle = FreeStyle;\n/**\n * Exports a simple function to create a new instance.\n */\n\nfunction create(hash, debug, changes) {\n  return new FreeStyle(hash, debug, undefined, changes);\n}\n//# sourceMappingURL=free-style.js.map"},"hash":"5c353c39ddbd82dc5f7be2e2bd13e95e"}