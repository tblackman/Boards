{"dependencies":[{"name":"./formatting","loc":{"line":1,"column":50}},{"name":"./utilities","loc":{"line":2,"column":28}},{"name":"free-style","loc":{"line":3,"column":27}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeStyle = undefined;\n\nvar _formatting = require(\"./formatting\");\n\nvar _utilities = require(\"./utilities\");\n\nvar _freeStyle = require(\"free-style\");\n\nvar FreeStyle = _interopRequireWildcard(_freeStyle);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Creates an instance of free style with our options\n */\nvar createFreeStyle = function createFreeStyle() {\n  return FreeStyle.create(\n  /** Use the default hash function */\n  undefined,\n  /** Preserve $debugName values */\n  true);\n};\n/**\n * Maintains a single stylesheet and keeps it in sync with requested styles\n */\nvar TypeStyle = /** @class */function () {\n  function TypeStyle(_a) {\n    var autoGenerateTag = _a.autoGenerateTag;\n    var _this = this;\n    /**\n     * Insert `raw` CSS as a string. This is useful for e.g.\n     * - third party CSS that you are customizing with template strings\n     * - generating raw CSS in JavaScript\n     * - reset libraries like normalize.css that you can use without loaders\n     */\n    this.cssRaw = function (mustBeValidCSS) {\n      if (!mustBeValidCSS) {\n        return;\n      }\n      _this._raw += mustBeValidCSS || '';\n      _this._pendingRawChange = true;\n      _this._styleUpdated();\n    };\n    /**\n     * Takes CSSProperties and registers it to a global selector (body, html, etc.)\n     */\n    this.cssRule = function (selector) {\n      var objects = [];\n      for (var _i = 1; _i < arguments.length; _i++) {\n        objects[_i - 1] = arguments[_i];\n      }\n      var object = (0, _formatting.ensureStringObj)(_utilities.extend.apply(void 0, objects)).result;\n      _this._freeStyle.registerRule(selector, object);\n      _this._styleUpdated();\n      return;\n    };\n    /**\n     * Renders styles to the singleton tag imediately\n     * NOTE: You should only call it on initial render to prevent any non CSS flash.\n     * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.\n     **/\n    this.forceRenderStyles = function () {\n      var target = _this._getTag();\n      if (!target) {\n        return;\n      }\n      target.textContent = _this.getStyles();\n    };\n    /**\n     * Utility function to register an @font-face\n     */\n    this.fontFace = function () {\n      var fontFace = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        fontFace[_i] = arguments[_i];\n      }\n      var freeStyle = _this._freeStyle;\n      for (var _a = 0, _b = fontFace; _a < _b.length; _a++) {\n        var face = _b[_a];\n        freeStyle.registerRule('@font-face', face);\n      }\n      _this._styleUpdated();\n      return;\n    };\n    /**\n     * Allows use to use the stylesheet in a node.js environment\n     */\n    this.getStyles = function () {\n      return (_this._raw || '') + _this._freeStyle.getStyles();\n    };\n    /**\n     * Takes keyframes and returns a generated animationName\n     */\n    this.keyframes = function (frames) {\n      var _a = (0, _formatting.explodeKeyframes)(frames),\n          keyframes = _a.keyframes,\n          $debugName = _a.$debugName;\n      // TODO: replace $debugName with display name\n      var animationName = _this._freeStyle.registerKeyframes(keyframes, $debugName);\n      _this._styleUpdated();\n      return animationName;\n    };\n    /**\n     * Helps with testing. Reinitializes FreeStyle + raw\n     */\n    this.reinit = function () {\n      /** reinit freestyle */\n      var freeStyle = createFreeStyle();\n      _this._freeStyle = freeStyle;\n      _this._lastFreeStyleChangeId = freeStyle.changeId;\n      /** reinit raw */\n      _this._raw = '';\n      _this._pendingRawChange = false;\n      /** Clear any styles that were flushed */\n      var target = _this._getTag();\n      if (target) {\n        target.textContent = '';\n      }\n    };\n    /** Sets the target tag where we write the css on style updates */\n    this.setStylesTarget = function (tag) {\n      /** Clear any data in any previous tag */\n      if (_this._tag) {\n        _this._tag.textContent = '';\n      }\n      _this._tag = tag;\n      /** This special time buffer immediately */\n      _this.forceRenderStyles();\n    };\n    /**\n     * Takes CSSProperties and return a generated className you can use on your component\n     */\n    this.style = function () {\n      var objects = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        objects[_i] = arguments[_i];\n      }\n      var freeStyle = _this._freeStyle;\n      var _a = (0, _formatting.ensureStringObj)(_utilities.extend.apply(void 0, objects)),\n          result = _a.result,\n          debugName = _a.debugName;\n      var className = debugName ? freeStyle.registerStyle(result, debugName) : freeStyle.registerStyle(result);\n      _this._styleUpdated();\n      return className;\n    };\n    /**\n     * Takes an object where property names are ideal class names and property values are CSSProperties, and\n     * returns an object where property names are the same ideal class names and the property values are\n     * the actual generated class names using the ideal class name as the $debugName\n     */\n    this.stylesheet = function (classes) {\n      var classNames = Object.getOwnPropertyNames(classes);\n      var result = {};\n      for (var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++) {\n        var className = classNames_1[_i];\n        var classDef = classes[className];\n        if (classDef) {\n          classDef.$debugName = className;\n          result[className] = _this.style(classDef);\n        }\n      }\n      return result;\n    };\n    var freeStyle = createFreeStyle();\n    this._autoGenerateTag = autoGenerateTag;\n    this._freeStyle = freeStyle;\n    this._lastFreeStyleChangeId = freeStyle.changeId;\n    this._pending = 0;\n    this._pendingRawChange = false;\n    this._raw = '';\n    this._tag = undefined;\n  }\n  /**\n   * Only calls cb all sync operations settle\n   */\n  TypeStyle.prototype._afterAllSync = function (cb) {\n    var _this = this;\n    this._pending++;\n    var pending = this._pending;\n    (0, _utilities.raf)(function () {\n      if (pending !== _this._pending) {\n        return;\n      }\n      cb();\n    });\n  };\n  TypeStyle.prototype._getTag = function () {\n    if (this._tag) {\n      return this._tag;\n    }\n    if (this._autoGenerateTag) {\n      var tag = typeof window === 'undefined' ? { textContent: '' } : document.createElement('style');\n      if (typeof document !== 'undefined') {\n        document.head.appendChild(tag);\n      }\n      this._tag = tag;\n      return tag;\n    }\n    return undefined;\n  };\n  /** Checks if the style tag needs updating and if so queues up the change */\n  TypeStyle.prototype._styleUpdated = function () {\n    var _this = this;\n    var changeId = this._freeStyle.changeId;\n    var lastChangeId = this._lastFreeStyleChangeId;\n    if (!this._pendingRawChange && changeId === lastChangeId) {\n      return;\n    }\n    this._lastFreeStyleChangeId = changeId;\n    this._pendingRawChange = false;\n    this._afterAllSync(function () {\n      return _this.forceRenderStyles();\n    });\n  };\n  return TypeStyle;\n}();\nexports.TypeStyle = TypeStyle;"},"hash":"04df3e38f6980f84a9fdf3a7720b63c0"}